# 数组的排序：冒泡排序与选择排序

下方为交换变量原理：var 一个新的值作为中介变量进行交换

	var arr = [5, 2]
	if (arr[1] > arr[2]) {
	    var tamp = arr[1]
	    arr[1] = arr[2]
	    arr[2] = tamp
	}

## 冒泡排序

核心原理：从第一个元素值开始，把它与后面的相继进行比较，通过交换变量的方式，将满足要求的元素值通过交换变量的方法传递至目标位置，以逐个实现，从前到后的每个元素都能处于合理位置。

<u>**冒泡排序代码示例**</u>

    var arr = [5, 4, 3, 2, 1]
    for (var a = 0; a < arr.length - 1; a++) {
        for (let j = 0; j < arr.length - 1 - a; j++) {
            if (arr[j] > arr[j + 1]) {
                var tamp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = tamp
            }
        }
    }
    document.write(arr)

## <u>**选择排序**</u>

核心原理：从第一个元素开始，把它开始与后面的进行比较，只要碰到比自己小（大）的就把值换过来，接着往后进行比较，第一个元素比较arr.length-1次，第二个比较arr.length-2次。依次把元素值，换过来，这样可以是的第一个数字保持是最小的，然后是第二个，然后是第三个。

 	var arr = [5, 2, 4, 1, 3]
 	for (let i = 0; i < arr.length - 1; i++) {
 	    for (let j = i + 1; j < arr.length ; j++) {
 	        if (arr[i] > arr[j]) {
 	            var tamp = arr[i]
 	            arr[i] = arr[j]
 	            arr[j] = tamp
 	        }
 	    }
 	}
 	document.write(arr)

关于一些理解：

二者的区别：冒泡排序的内部循环减少是因为先确定了大的数字在最后，完成了寻找，每一次循环还是在从第一个开始，不过不需要去与已经确定的数字进行比较，所以在内部循环上限需要进行arr.length-1-i的操作。

​						选择排序内部循环减少的方法是从前往后依次拿项目去跟后面的比较，从前往后逐个确定谁是最小值，所以，每次寻找都需要比较到最后一个，但是每次比较开始项目的脚标在依次增大，所以内循环的终止一直都是最末一个项目，增加的是比较开始点的脚标。

